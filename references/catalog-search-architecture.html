---
title: Katalogsuche Architektur
parent: References
---

<article class="bcls-article">
  <h1>Katalog-Sucharchitektur</h1>
  <summary>In diesem Thema erfahren Sie mehr über die Architektur von Brightcove für seine Katalogsuchtechnologie.</summary>
  <section class="bcls-section">
    <h2 id="Overview">Überblick</h2>
    <p >Ab April 2019 wurde die Funktion der Katalogsuche auf Elasticsearch aktualisiert. Dieses Upgrade bietet eine Reihe von Vorteilen, darunter die verbesserte Relevanz und Genauigkeit sowie eine dramatisch verbesserte Leistung - die Reaktionszeit ist viel konsistenter und im Allgemeinen doppelt so schnell. Diese neue Funktionalität wirkt sich auf die CMS-API, die Wiedergabe-API, die interaktive Studio-Suche und die Katalogsuchmethoden aus.</p>
    <p >Während Brightcove erhebliche Anstrengungen unternommen hat, um Elasticsearch-Ergebnisse konsistent zu machen, gibt es Unterschiede, und es besteht eine geringe Möglichkeit, dass sich Ihre Integration möglicherweise nicht wie erwartet verhält, wenn Sie bestimmte Abhängigkeiten von Suchergebnissen codiert haben.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Search_Result_Differences_and_Impact">Unterschiede und Auswirkungen des Suchergebnisses</h2>
    <p >Bei der Untersuchung der potenziellen Auswirkungen hat Brightcove festgestellt, dass mehr als 90% der Suchanfragen Ergebnisse zurückgeben, die in Bezug auf die Anzahl der zurückgegebenen Ergebnisse übereinstimmen. Dies ist ein Indikator dafür, dass die erwarteten Ergebnisse nicht unterschiedlich genug sein sollten, um Probleme mit API-Integrationen zu verursachen.</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="comparison" src="/assets/images/references/catalog-search/comparison.png" /></figure>
    <p >Diese Grafik zeigt die Anzahl der Suchergebnisse, die genau mit der Anzahl der Ergebnisse zwischen den beiden Systemen in Blau übereinstimmen, und denen, die sich in der Zahl in Rot unterscheiden.</p>
    <p >Im Rahmen unseres Rollouts werden alle Standardsuchanfragen, diese Suchen nach der leeren Zeichenfolge, bereits seit mehreren Monaten von Elasticsearch bereitgestellt - so dass Benutzer Elasticsearch-Ergebnisse bereits ohne Probleme sehen und verwenden.</p>
    <p >Es gibt jedoch Einschränkungen, was wir aus dieser Art von Vergleich lernen können. Im besten Fall können wir nur die Absicht einer bestimmten Suche ableiten, und Katalogdaten sind fließend.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Known_Differences">Bekannte Unterschiede</h2>
    <p >Die folgenden Unterschiede sind weitgehend grundlegend oder das Ergebnis von Entscheidungen, die nach einer umfassenden Analyse der Suchergebnisse getroffen wurden - sie sind unmöglich vollständig zu beseitigen.</p>
    <h3>Stemming</h3>
    <p ><a href="https://en.wikipedia.org/wiki/Stemming">Stemming</a> ist der Prozess, bei dem gebeugte (oder manchmal abgeleitete) Wörter auf ihren <a href="https://en.wikipedia.org/wiki/Word_stem">Wortstamm</a>, ihre Basis oder ihre <a href="https://en.wikipedia.org/wiki/Root_(linguistics)"></a> Wurzelform reduziert werden - im Allgemeinen ein geschriebenes Wort bilden.</p>
    <p >Ein Stemmer für Englisch, der am Vorbau operiert <em>Katze</em> sollte solche <a href="https://en.wikipedia.org/wiki/String_literal">Strings</a> wie <em>Katzen</em>, <em>katzenartig</em> und <em>Catty</em>. Ein Stemming-Algorithmus könnte auch die Wörter reduzieren <em>angeln</em>, <em>gefischt</em> und <em>Fischer</em> bis zum Stiel <em>angeln</em>. Der Stamm muss kein Wort sein, zum Beispiel reduziert der Porter-Algorithmus <em>streiten</em>, <em>argumentiert</em>, <em>argumentiert</em>, <em>streiten</em> und <em>Argus</em> bis zum Stiel <em>Argu</em>.</p>
    <p >Unsere bestehende Suche verwendet den Stemmer von Lancaster (Paice/Husk), dieser Algorithmus wird allgemein als übermäßig aggressiv angesehen - dies führt zum Beispiel zu einem Mangel an Unterscheidung <em>Feuerzeug</em> und <em>Licht</em> würde unter Lancaster als der gleiche Begriff angesehen werden.</p>
    <p >Elasticsearch verwendet einen neueren und viel weniger aggressiven Algorithmus (Porter2), der in der Industrie breite Akzeptanz gewonnen hat und allgemein als signifikante Verbesserung angesehen wird (Lancaster ist jetzt selten). Die Änderung des Stemmers wirkt sich möglicherweise auf einen signifikanten (~ 35%) Anteil der Suchanfragen aus: Das heißt nicht, dass die Ergebnisse unterschiedlich</strong> sein <strong>werden, nur dass sie unterschiedlich</strong> sein <strong>könnten - aber im Allgemeinen dies sollte zum Besseren sein: Allerdings sind einige Teilmengen der Kunden möglicherweise auf das alte Verhalten angewiesen.</p>
    <h3>Relevanz</h3>
    <p >Unsere bestehende Suche scheint eine strengere TF-Normalisierung zu haben. Dies bewirkt eine andere Relevanzsorte für Begriffe, die in größeren Feldern gefunden werden (d. h. existierende betrachtet die Übereinstimmung als weniger relevant, da sie dem Begriff weniger Gewicht verleiht, da er im Verhältnis zur Länge des Dokuments kleiner ist).</p>
    <h3>Sonderzeichen</h3>
    <p >Sonderzeichen werden in unserer bestehenden Suche entfernt, dies entspricht ziemlich dem Strippen von Interpunktionen und verwandten Zeichen - anstatt sie zu strippen, entkommen wir ihnen im Allgemeinen in Elasticsearch, daher besteht die Möglichkeit, dass eine Suche sie stattdessen berücksichtigt.</p>
    <h3>Begriff Handling</h3>
    <p >Bestehende Suchanfragen führen „term smooshing“ aus, während wir in Elasticsearch fehlerhafte Begriffe fallen lassen, betrachten Sie diese Suche mit einem leeren <code translate="No">tags:</code> Begriff: <code translate="No">q=tags: state:ACTIVE</code></p>
    <ul>
      <li><strong>Bestehende</strong>: <code translate="No">tags:state:ACTIVE</code>— Suche nach Videos mit einem Tag von <code translate="No">state:ACTIVE</code></li>
      <li><strong>Elasticsearch</strong>: <code translate="No">state:ACTIVE</code>— lass den leeren Begriff fallen</li>
    </ul>
    <p >Es gibt eine Reihe von subtilen Edge-Fällen im Zusammenhang mit der Behandlung von baumelnden Interpunktionen und Abfragen, die im Allgemeinen fehlerhaft sind. Wir versuchen zu produzieren, was die Abfrage unserer Meinung nach sein sollte, aber in diesen Fällen raten wir leider, was ein Benutzer beabsichtigt haben könnte (wann wir wirklich einen Fehler hätten zurückgeben sollen damit sie ihre Suche verfeinern können)</p>
    <h3>Nur spielbar</h3>
    <p >Es gibt zwei Mechanismen, um eine Suche auf Videos zu beschränken, die derzeit abspielbar sind: Die Abfrage kann ein Flag enthalten, oder die Abfrage selbst kann einen Aspekt der Spielbarkeit erfordern.</p>
    <ul>
      <li>Existing: Dies wird basierend auf dem Wert eines Feldes abgefragt, das aktualisiert wird</li>
      <li>Elasticsearch: Dies wird basierend auf berechneten Datumsbereichen abgefragt</li>
    </ul>
    <p >Elasticsearch sollte im Allgemeinen genauer sein und bessere Ergebnisse erzielen (es gibt eine Verzögerung im Zusammenhang mit dem bestehenden Mechanismus, und der Flaggenwartungsmechanismus ist nicht vollständig zuverlässig).</p>
    <h3>Indexgenauigkeit</h3>
    <p >Der Elasticsearch-Index ist „frischer“ als der vorhandene Index und spiegelt Aktualisierungen tendenziell schneller wider - dies ist nicht immer der Fall, aber im Allgemeinen besteht die Erfahrung mit Elasticsearch darin, dass die Ergebnisse den Status der zugrunde liegenden Katalogdaten genauer widerspiegeln. Sowohl vorhandene als auch Elasticsearch sind verteilte Systeme und daher nicht vollständig konsistent in den Ergebnissen, die sie zurückgeben: Eine wiederholte Abfrage gegen beide Systeme kann möglicherweise unterschiedliche Ergebnisse liefern (insbesondere in dem Fall, in dem eine Reihe gleichzeitig ausgeführter Löschoperationen vorliegen).</p>
    <p >Bestehende Suchergebnisse ändern sich basierend auf dem Status des Shards, dem ein Konto zugewiesen ist - der globale Status eines bestimmten Shard kann (und tut) die Ergebnisse einer bestimmten Abfrage beeinflussen: Elasticsearch hat diesen Mangel nicht.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Examples">Beispiele</h2>
    <h3>Beispiel 1</h3>
    <p >Nehmen wir an, es gibt zwei Videos mit den folgenden Titeln:</p>
    <pre>
  <code class="language-html" translate="No">Video#1: has the title “Don’t look into the light”
  Video#2: has the title “Using a lighter to make a campfire”</code></pre>
    <p >Der Benutzer möchte alle Videos zurückgeben, die das Wort „Licht“ haben müssen. Mit der CMS-API würde die Abfrage wie folgt aussehen:</p>
    <pre>
  <code class="language-html" translate="No">q=%2Blight or q=+light</code></pre>
    <p >Bei der bestehenden Suche werden beide Videos in der Reihenfolge zurückgegeben:</p>
    <pre>
  <code class="language-html" translate="No">Video#2 - “Using a lighter to make a campfire”
  Video#1 - “Don’t look into the light”</code></pre>
    <p >Es gibt zwei Probleme damit:</p>
    <ul>
      <li><strong>Relevanz</strong>: Die Bestellung ist falsch. „Schau nicht ins Licht“ (Video #2) sollte erscheinen, bevor „Feuerzeug benutzt, um ein Lagerfeuer zu machen“ (Video #1)</li>
      <li><strong>Genauigkeit</strong>: „Verwenden eines Feuerzeugs, um ein Lagerfeuer zu machen“ sollte nicht einmal in der Ergebnismenge erscheinen, da das Wort „Licht“ im Videotitel überhaupt nicht erscheint.</li>
    </ul>
    <p >Mit Elasticsearch wird dies nur Video eins zurückgeben:</p>
    <pre>
  <code class="language-html" translate="No">Video#1 - “Don’t look into the light”</code></pre>
    <p >Dies ist eine Verbesserung, weil:</p>
    <ul>
      <li>Relevanz: Die Reihenfolge ist korrekt.</li>
      <li>Genauigkeit: Es wird nur Video eins zurückgegeben, da es das einzige Video mit dem Wort „Licht“ im Titel ist.</li>
    </ul>
    <h3>Beispiel 2</h3>
    <p >Wie in unserer <a href="https://apis.support.brightcove.com/cms/searching/cmsplayback-api-videos-search.html#Stemming">CMS-API-Dokumentation zum Einstemming beschrieben</a>, wird Stemming unterstützt, aber keine teilweise Wortsuche. Nehmen wir an, es gibt 5 Videos mit den folgenden Titeln:</p>
    <pre>
  <code class="language-html" translate="No">Video#1 - "Parking Ban Announced"
  Video#2 - "Parking to be Banned"
  Video#3 - "City Banning Parking"
  Video#4 - "Bank Holiday"
  Video#5 - "Bandit Captured"</code></pre>
    <p >Der Benutzer möchte alle Videos zurückgeben, die das Wort <strong>Ban</strong> im Namensfeld haben müssen. Mit der CMS-API würde die Abfrage wie folgt aussehen:</p>
    <pre>
  <code class="language-html" translate="No">q=%2Bname%3Aban or q=+name:ban</code></pre>
    <p >Es wird erwartet, dass „Ban“, „Banning“ und „Banned“ zu Suchergebnissen führen würden, da „Ban“ ein Stamm aller drei ist.</p>
    <p >Mit dem aktuellen Suchsystem werden jedoch alle fünf Videos in dieser Reihenfolge zurückgegeben:</p>
    <pre>
  <code class="language-html" translate="No">Video#2 - "Parking to be Banned"
  Video#3 - "City Banning Parking"
  Video#1 - "Parking Ban Announced"
  Video#4 - "Bank Holiday"
  Video#5 - "Bandit Captured"</code></pre>
    <p >Auch hier gibt es zwei Probleme:</p>
    <ul>
      <li>Relevanz: Die Bestellung ist falsch. „Parkverbot angekündigt“ sollte das erste zurückgegebene Video sein, da es das Wort „Ban“ enthält.</li>
      <li>Genauigkeit: „Feiertag“ und „Bandit Captured“ sollten überhaupt nicht zurückgegeben werden, da „Ban“ nicht Teil des Wortes „Bank“ oder „Bandit“ ist.</li>
    </ul>
    <p >Mit Elasticsearch sehen die Ergebnisse wie folgt aus:</p>
    <pre>
  <code class="language-html" translate="No">Video#1 - "Parking Ban Announced"
  Video#2 - "Parking to be Banned"
  Video#3 - "City Banning Parking"</code></pre>
    <p >Dies ist eine Verbesserung, weil:</p>
    <ul>
      <li>Relevanz: Die Reihenfolge ist korrekt.</li>
      <li>Genauigkeit: Es werden nur Videos mit den Stielen des Wortes „Ban“ („Ban“, „Banning“ und „Banned“) zurückgegeben.</li>
    </ul>
  </section>
</article>