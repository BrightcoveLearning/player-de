---
title: 'Leitfaden zum Lernen: Verwenden der REST-APIs'
description: 'In diesem Thema erhalten Sie zunächst einen allgemeinen Überblick über die Verwendung der REST-APIs. Später im Dokument wird dann ein tieferer Einblick in den Beispielcode gegeben. Das erste Beispiel verwendet die <span translate="No">Analytics-API</span> um die Anzahl der Aufrufe des aktuell im Player befindlichen Videos abzurufen und in der Brightcove-Player-Steuerleiste anzuzeigen. Das zweite und etwas komplexere Beispiel verwendet die <span translate="No">Analytics-API</span> in Verbindung mit dem Brightcove Player-Katalog, um die beliebtesten Videos von einem Konto abzurufen und in einer Wiedergabeliste anzuzeigen. Die Codediskussion in diesem Dokument konzentriert sich auf das Abrufen der gewünschten Daten aus der richtigen REST-API.'
parent: Getting Started
---


<!-- 
  This content appears on:
  
  https://apis.support.brightcove.com/getting-started/learning-guide-using-rest-apis.html

  https://player.support.brightcove.com/getting-started/learning-guide-using-rest-apis.html

  If you update in one place, you MUST update it in all!
 -->

 <h1>{{ page.title }}</h1>
 <article class="bcls-article">
  <summary>{{ page.description }}</summary>
  <section class="bcls-section">
    <h2 id="High_level_view">Ansicht auf hoher Ebene</h2>
    <p>Um die REST-APIs verwenden zu können, müssen einige Teile vorhanden sein. Kurz gesagt sind es:</p>
    <ul>
      <li><strong>Kundencode</strong>: Der Client-Code fragt nach bestimmten Daten und zeigt sie dann entsprechend den Anwendungsanforderungen an. Der Client-Code wird in diesem Dokument ausführlich behandelt, da Sie ihn am häufigsten schreiben müssen.</li>
      <li><strong>Proxy Server</strong>: Aus Sicherheitsgründen akzeptieren die REST-APIs keine Datenanforderungen direkt vom Client, da dies das Senden vertraulicher Informationen wie Client-Anmeldeinformationen vom Client fördern würde. Dies bedeutet, dass ein Proxy als Vermittler zwischen dem Client und der REST-API fungiert. Der in den Beispielen verwendete Proxy ist in PHP geschrieben und wird später in diesem Dokument erläutert. Der Proxy muss auf einem Server unter Ihrer Kontrolle eingerichtet werden und kann in der Sprache Ihrer Wahl geschrieben werden. Die vorgeschlagene Konfiguration des Proxys ermöglicht es, ihn einmal zu schreiben und von einer der APIs zu verwenden.</li>
      <li><strong>REST-APIs</strong>: Brightcove bietet einen umfassenden Satz von APIs zum Anpassen, Erweitern und Integrieren in die Brightcove-Plattform. Siehe die <a href="https://apis.support.brightcove.com/getting-started/getting-started-brightcove-apis.html">Überblick: Video Cloud-APIs</a> Dokument für weitere Informationen.</li>
    </ul>
    <p>Das folgende Diagramm zeigt die Interaktion zwischen den drei Kernelementen des Prozesses zum Abrufen von Daten von einer der REST-APIs von Brightcove:</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="Basic Pieces Overview" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/client-proxy-api.png" /></figure>
  </section>
  <section class="bcls-section">
    <h2 id="Client_functionality_overview">Übersicht über die Client-Funktionalität</h2>
    <p>Der clientseitige Code ändert sich erheblich, je nachdem, von welcher API Sie Daten anfordern. Wie oben erwähnt, handelt es sich beim Proxy um einen einmaligen Schreibzugriff und keine Änderung des Codes, und die APIs werden von Brightcove verwaltet. Aus diesem Grund liegt der Schwerpunkt des Dokuments darauf, zu lernen, wie Sie den Clientcode ändern, um die gewünschten Daten von einer der APIs abzurufen.</p>
    <p>Das folgende Diagramm konzentriert sich auf die wichtigsten Teile des Client-Codes, nämlich:</p>
    <ul>
      <li>Die Funktion, die den <code translate="No">HTTPRequest</code> zum Stellvertreter. Um Mehrdeutigkeiten zu vermeiden, heißt die Funktion <code translate="No">makeRequest()</code>. Es ist auf der rechten Seite des Diagramms unten abgebildet.</li>
      <li>Der Code, der die erforderlichen Informationen für die Anforderung sammelt. Es ist oben links im Diagramm abgebildet. Dieser Code ist normalerweise recht einfach und verwendet Konzepte, die selbst Programmieranfängern gut bekannt sind.</li>
      <li>Der Aufruf, der das zuvor erwähnte ausführt <code translate="No">makeRequest()</code> Funktion. Es ist unten links im Diagramm abgebildet. Der Aufruf übergibt eine Funktion an <code translate="No">makeRequest()</code> als Parameter. Dann in <code translate="No">makeRequest()</code> diese Funktion wird aufgerufen. Dies ist ein Beispiel für ein anonym definiertes <strong>zurückrufen</strong> Funktion.</li>
    </ul>
    <p>Sie sehen die beiden Abschnitte im Diagramm mit der Bezeichnung <strong>Asynchrone Aktivität</strong>. Obwohl im Diagramm an zwei verschiedenen Stellen dargestellt, ist dies tatsächlich dieselbe asynchrone Aktivität und stellt die unbekannte Zeit dar, die für Folgendes benötigt wird:</p>
    <ul>
      <li>Der Client, um die Anfrage an den Proxy zu senden.</li>
      <li>Der Proxy zum Anfordern von Daten von der API.</li>
      <li>Die API zum Erstellen des Resultsets und zum Zurückgeben an den Proxy.</li>
      <li>Der Proxy, um die Daten an den Client zurückzugeben.</li>
    </ul>
    <p>Beachten Sie, dass die logischen Flusspfeile aus der Box, die aufruft, <code translate="No">makeRequest()</code> (unteres linkes Feld) scheinen darauf hinzuweisen, dass der Code zu zwei verschiedenen Zeitpunkten ausgeführt wird, was genau der Fall ist. Der Aufruf der Funktion erfolgt, aber die Callback-Funktion wird erst ausgeführt, wenn <code translate="No">makeRequest()</code> hat seine Arbeit erledigt und die Callback-Funktion wird ausgeführt, die die angeforderten Daten an den Funktionsaufrufcode zurückgibt.</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="Client functionality overview" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/proxy-API-call.png" /></figure>
  </section>
  <section class="bcls-section">
    <h2 id="Example_code_walkthrough">Beispielcode-Komplettlösung</h2>
    <p>Anstatt den Code als Ganzes zu betrachten, wird er in Abschnitten vorgestellt und diskutiert. Einige der Abschnitte beziehen sich auf das obige Diagramm.</p>
    <h3>Standard-Spielercode</h3>
    <p>Dieser Codeabschnitt enthält den grundlegenden Brightcove Player-In-Page-Einbettungscode.</p>
    <ul>
      <li>Zeilen 11-21: Standard-Brightcove Player-Code mit dem Zusatz eines&nbsp;<code translate="No">id</code> Attribut hinzugefügt.</li>
    </ul>
    <pre class="line-numbers">
	<code class="language-html" translate="No">&lt;!doctype html&gt;
	&lt;html&gt;
	
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;Untitled Document&lt;/title&gt;
	&lt;/head&gt;
	
	&lt;body&gt;
	
	&lt;video-js id="myPlayerID"
		data-video-id="3851380732001"
		data-account="1752604059001"
		data-player="HkAzSmB0l"
		data-embed="default"
		data-application-id
		class="video-js"
		controls
		width="640"
		height="360"&gt;&lt;/video-js&gt;
	&lt;script src="https://players.brightcove.net/1752604059001/HkAzSmB0l_default/index.min.js"&gt;&lt;/script&gt;</code></pre>
    <h3>Anruf vorbereiten</h3>
    <p>Dieser Codeabschnitt initialisiert Variablen und bereitet den Aufruf von . vor <code translate="No">makeRequest()</code>. Im Allgemeinen müssen Sie für eine Leseanfrage die folgenden Informationen angeben:</p>
    <ol>
      <li>Die URL zu dem Proxy, den Sie verwenden, zum Beispiel (dies muss natürlich ein Proxy unter Ihrer Kontrolle sein):
        <pre class="line-numbers">
	<code class="language-html" translate="No">https://solutions.brightcove.com/bcls/bcls-proxy/doc-samples-proxy-v2.php</code></pre>
      </li>
      <li>Die für die eigentliche Anfrage benötigte URL, normalerweise dynamisch aufgebaut:
        <pre class="line-numbers">
	<code class="language-html" translate="No">https://analytics.api.brightcove.com/v1/alltime/accounts/1752604059001/videos/4825279519001</code></pre>
      </li>
      <li>Die HTTP-Methode zum Beispiel <code translate="No">GET</code>.</li>
    </ol>
    <p>Es folgt ein Beispiel:</p>
    <ul>
      <li>Zeile 1: Standardcode, um zu warten, bis der Spieler bereit ist, mit ihm zu interagieren.</li>
      <li>Zeilen 2-4: Erstellen/Festlegen von Werten für Variablen, die später im Code benötigt werden.</li>
      <li>Zeilen 7-12: Warte auf die <code translate="No">loadstart</code> Veranstaltung so die <code translate="No">mediainfo</code> Objekt ist gefüllt. Weisen Sie Variablen zu, um Werte zu speichern, die für die <span translate="No">Analytics-API</span> Endpunkt.</li>
      <li>Zeile 13: Legen Sie die HTTP-Methode für den Aufruf fest.</li>
    </ul>
    <pre class="line-numbers">
	<code class="language-javascript" translate="No">videojs.getPlayer('myPlayerID').ready(function() {
	&nbsp; var myPlayer = this,
		accountId = myPlayer.bcinfo.accountId,
		options = {};
	
		// +++ Wait for loadstart event so can use mediainfo object +++
		myPlayer.on('loadstart', function() {
			var videoId = myPlayer.mediainfo.id,
			baseURL = 'https://analytics.api.brightcove.com/v1/alltime/accounts/',
			endPoint = accountId + '/videos/' + videoId;
			options.proxyURL = "https://solutions.brightcove.com/bcls/bcls-proxy/doc-samples-proxy-v2.php";
			options.url = baseURL + endPoint;
			options.requestType = "GET";</code></pre>
    <aside class="bcls-aside bcls-aside--information">Hinweis: Die Linien 9,10 und 12 könnten leicht zu einer einzigen langen Linie zusammengefasst werden. Der Code wurde wie gezeigt geschrieben, um lange Zeilen zu vermeiden, die ein Scrollen zum Anzeigen erfordern, und um die Wiederverwendbarkeit des Codes zu unterstützen.</aside>
    <h3>Anruf <code translate="No">makeRequest()</code></h3>
    <p>Dieser Codeabschnitt macht den Aufruf an <code translate="No">makeRequest()</code> Funktion. Beachten Sie, dass zwei Parameter übergeben werden. Das erste ist das Optionsobjekt, das Informationen für den Endpunkt enthält, und das zweite ist die Callback-Funktion. Denken Sie daran, dass dies ein asynchroner Aufruf ist, sodass die anonym definierte Callback-Funktion erst aufgerufen wird, wenn Daten von der REST-API an die . zurückgegeben wurden <code translate="No">makeRequest()</code> Funktion.</p>
    <ul>
      <li>Zeile 1: Ruf die <code translate="No">makeRequest()</code> Funktion und übergibt die erforderlichen Werte für den Aufruf im <code translate="No">options</code> Objekt. In diesem Fall enthält das Objekt Folgendes:
        <figure class="bcls-figure"><img class="bcls-image" alt="options object" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/options-object-console.png" /></figure>
      </li>
      <li>Zeilen 3-13: Die Callback-Funktion ist als anonyme Funktion definiert (gelb hervorgehoben). Denken Sie daran, dass diese Funktion ein Parameter ist und NICHT hier, sondern später im Code aufgerufen wird.</li>
      <li>Zeilen 6, 8, 10: <code translate="No">console.log()</code> Aussagen, die anzeigen:
        <ul>
          <li>Der unformatierte JSON-String, der vom API-Aufruf zurückgegeben wird.</li>
          <li>Das von der . generierte JSON-Objekt <code translate="No">JSON.parse()</code> -Methode, die die Konvertierung von Strings in ein Objekt durchführt.</li>
          <li>Die tatsächliche Anzahl der Ansichten, extrahiert aus dem Objekt mithilfe von simple <code translate="No">object.property</code> Notation.</li>
        </ul>
      </li>
      <li>Zeile 12: Ruft die Funktion auf, die die Anzahl der Ansichten in der Steuerleiste anzeigt.</li>
    </ul>
    <p>Der folgende Screenshot von der Konsole zeigt tatsächlich angezeigte Daten aus dem <code translate="No">console.log</code> Aussagen:</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="Processing of data in callback function" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/console-data-process-callback-function.png" /></figure>
    <pre class="line-numbers">
	<code class="language-javascript" translate="No">// +++ Make the request to the <span translate="No">Analytics API</span> +++
	// Extract views from data returned by Analytics API
	makeRequest(options, <span class="bcls-highlight">function(viewsRaw) {
	var viewsCount;
	// Remove console.log command for production code
	console.log('viewsRaw', viewsRaw);
	viewsObject = JSON.parse(viewsRaw);
	console.log('viewsObject', viewsObject);
	viewsCount = viewsObject.alltime_video_views;
	console.log('views', viewsCount);
	// Call function to place data in controlbar
	placeCountInControlbar(viewsCount);
	}</span>);</code></pre>
    <h3>Tatsächlich <code translate="No">makeRequest()</code> Funktion</h3>
    <p>In diesem Abschnitt des Dokuments wird der Code untersucht, der tatsächlich das . definiert <code translate="No">makeRequest()</code> Funktion. Der Code, der die Funktion definiert, ist so geschrieben, dass er NICHT geändert, sondern so wie er ist wiederholt verwendet werden muss. Sie können in Randfällen feststellen, dass dies nicht der Fall ist, aber für die überwiegende Mehrheit der Anwendungen muss dieser Code NICHT geändert werden.</p>
    <aside class="bcls-aside bcls-aside--tip">Ein Schlüsselkonzept zum Verständnis der <code translate="No">makeRequest()</code> Funktion besteht darin, Erkenntnisse darüber zu gewinnen, wie die <code translate="No">XMLHttpRequest</code> Objekt verhält sich. Die <code translate="No">XMLHttpRequest.onreadystatechange</code> ist ein Event-Handler, der immer dann aufgerufen wird, wenn die <code translate="No">readyState</code> Attributänderungen. Der ihm zugewiesene Wert ist der von Ihnen geschriebene Event-Handler-Funktionscode. Die folgende Tabelle zeigt die Werte der <code translate="No">readyState</code> Attribut haben kann und was jeder Wert bedeutet:
      <table class="bcls-table">
        <thead class="bcls-table__head">
          <tr>
            <td class="header">Wert</td>
            <td class="header">Bundesland</td>
            <td class="header">Beschreibung</td>
          </tr>
        </thead>
        <tbody class="bcls-table__body">
          <tr>
            <td><code translate="No">0</code></td>
            <td><code translate="No">UNSENT</code></td>
            <td>Mandant wurde erstellt. <code translate="No">open()</code> noch nicht angerufen.</td>
          </tr>
          <tr>
            <td><code translate="No">1</code></td>
            <td><code translate="No">OPENED</code></td>
            <td><code translate="No">open()</code> has been called.</td>
          </tr>
          <tr>
            <td><code translate="No">2</code></td>
            <td><code translate="No">HEADERS_RECEIVED</code></td>
            <td><code translate="No">send()</code> has been called, and headers and status are available.</td>
          </tr>
          <tr>
            <td><code translate="No">3</code></td>
            <td><code translate="No">LOADING</code></td>
            <td>Wird heruntergeladen; <code translate="No">responseText</code> enthält Teildaten.</td>
          </tr>
          <tr>
            <td><code translate="No">4</code></td>
            <td><code translate="No">DONE</code></td>
            <td>Der Vorgang ist abgeschlossen.</td>
          </tr>
        </tbody>
      </table>
      <p>Sie sehen im Code genau, wie der Ereignishandler verwendet wird.</p>
    </aside>
    <p>Es folgt eine zeilenweise Diskussion des Codes:</p>
    <ul>
      <li>Zeilen 1-6: Funktionsdefinition und Variablenerstellung. Ein wichtiger Punkt ist, dass ein neues <code translate="No">XMLHttpRequest</code> Objekt erstellt wird.</li>
      <li>Zeilen 8, 26: Definiert die Event-Handler-Funktion für <code translate="No">readyState</code> Änderungen.</li>
      <li>Zeilen 9, 23, 25: Benutze einen <code translate="No">try-catch</code> falls die Anfrage auf hohem Niveau fehlschlägt.</li>
      <li>Zeilen 10, 11: Verwenden <code translate="No">if</code> Anweisungen, um sicherzustellen, dass die Anfrage abgeschlossen ist (<code translate="No">readyState</code> 4) und erfolgreich abgeschlossen ist, liegt der Status im Bereich 200. Im Folgenden wird die Konsolenprotokollierung der <code translate="No">readyState</code> und <code translate="No">status</code> Werte in der Event-Handler-Definition:
        <figure class="bcls-figure"><img class="bcls-image" alt="Logging readyState and status" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/console-readystate-and-status.png" /></figure>
      </li>
      <li>Zeile 18: Die Callback-Funktion wird ausgeführt. Dies übergibt die zurückgegebenen Daten von der API zurück an die Callback-Funktion, wie im Abschnitt beschrieben <strong>Aufruf von makeRequest()</strong> Abschnitt oben.</li>
      <li>Zeile 33: Legen Sie den Ereignishandler für die . fest <code translate="No">XMLHttpRequest.onreadystatechange</code> Veranstaltung.</li>
      <li>Zeile 35: Initialisiert die Anforderung an den Proxy.</li>
      <li>Zeile 38: Sendet die asynchrone Anforderung.</li>
    </ul>
    <pre class="line-numbers">
	<code class="language-javascript" translate="No">function makeRequest(options, callback) {
	var httpRequest = new XMLHttpRequest(),
	response,
	requestParams,
	dataString,
	proxyURL = options.proxyURL,
	// response handler
	getResponse = function() {
	try {
		if (httpRequest.readyState === 4) {
			if (httpRequest.status &gt;= 200 &amp;&amp; httpRequest.status &lt; 300) {
				response = httpRequest.responseText;
				// some API requests return '{null}' for empty responses - breaks JSON.parse
				if (response === '{null}') {
					response = null;
				}
				// return the response
				callback(response);
			} else {
				alert('There was a problem with the request. Request returned ' + httpRequest.status);
			}
		}
	} catch (e) {
		alert('Caught Exception: ' + e);
	}
	};
	/**
	* set up request data
	* the proxy used here takes the following request body:
	* JSON.stringify(options)
	*/
	// set response handler
	httpRequest.onreadystatechange = getResponse;
	// open the request
	httpRequest.open('POST', proxyURL);
	// set headers if there is a set header line, remove it
	// open and send request
	httpRequest.send(JSON.stringify(options));
	}</code></pre>
    <h3>Zeigen Sie die zurückgegebenen Daten an</h3>
    <p>Dieser Code zeigt, wie die zurückgegebenen Daten in die Steuerleiste eingefügt werden. Diese Funktion wird am Ende der Callback-Funktion aufgerufen, gezeigt in <strong>Aufruf von makeRequest()</strong> Abschnitt oben.</p>
    <ul>
      <li>Zeilen 5, 16: Definieren Sie die Funktion.</li>
      <li>Zeile 6: Erstellen Sie eine Variable für die <code translate="No">spacer</code> Element in der Steuerleiste.</li>
      <li>Zeile 7: Dynamisch erstellen a <code translate="No">div</code> Element.</li>
      <li>Zeile 9: Platzieren Sie eine Beschriftung und den Wert der Ansichten im neu erstellten <code translate="No">div</code> Element.</li>
      <li>Zeile 11: Verwenden Sie JavaScripts <code translate="No">document.getElementsByClassName()</code> Methode zum Abrufen der Steuerleiste <code translate="No">spacer</code> Element.</li>
      <li>Zeile 13: Style die <code translate="No">spacer</code> um die Gesamtanzahl der Aufrufe rechtsbündig und 10px vom oberen Rand des Bildschirms nach unten anzuzeigen <code translate="No">spacer</code>.</li>
      <li>Zeile 15: Fügen Sie das neu erstellte, gefüllte und gestylte Element dem . hinzu <code translate="No">spacer</code>.</li>
    </ul>
    <pre class="line-numbers">
	<code class="language-javascript" translate="No">/**
	* Dynamically build a div that is then
	* placed in the controlbar's spacer element
	*/
	function placeCountInControlbar(viewsCount) {
	var spacer,
	newElement = document.createElement('div');
	//Place data in div
	newElement.innerHTML = "Total Views: " + viewsCount;
	//Get the spacer in the controlbar
	spacer = document.getElementsByClassName('vjs-spacer')[0];
	//Right justify content in the spacer and add top margin
	spacer.setAttribute('style', 'justify-content: flex-end; margin-top: 10px');
	//Add the dynamically built div to the spacer in the controlbar
	spacer.appendChild(newElement);
	}</code></pre>
    <h3>Codeauflistung komplett</h3>
    <p>Der vollständige, funktionierende Code befindet sich in diesem GitHub-Repository: <a href="https://github.com/BrightcoveLearning/learning-guide-using-rest-apis/blob/master/display-views-in-controlbar.html">display-views-in-controlbar.html</a>.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Simple_debugging">Einfache Fehlersuche</h2>
    <p>Wie Sie sehen, sind bei der Verwendung der REST-APIs mehrere Teile beteiligt. Dies kann zu Herausforderungen führen, wenn eine App nicht richtig funktioniert. Wo fängt man mit dem Debuggen an?</p>
    <p>In diesem Abschnitt werden einige einfache Vorschläge gemacht, die ein großartiger Ausgangspunkt für Ihr Debugging-Abenteuer sind. In den folgenden beiden Abschnitten können Sie die grundlegendsten Informationen anzeigen, die Sie benötigen, was für den Anruf übergeben und zurückgegeben wird.</p>
    <h3>Anrufoptionen prüfen</h3>
    <p>Bei dem in diesem Dokument beschriebenen clientseitigen Code geht es im Wesentlichen darum, die richtigen Optionen für die Verwendung mit dem Proxy bereitzustellen, und wiederum die eigentliche API. Daher ist es für das korrekte Funktionieren Ihres Codes unerlässlich zu wissen, dass die Optionen korrekt sind. Eine einfache Möglichkeit, dies zu tun, ist, sich an der Konsole anzumelden <code translate="No">options</code> Objekt kurz bevor sie in die <code translate="No">makeRequest</code> Funktion wo sie verwendet werden:</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="debugging code log options" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/debugging-code-log-options.png" /></figure>
    <p>Was das Optionsobjekt enthält, hängt davon ab, was Sie tun möchten, aber einige Grundlagen werden immer vorhanden sein, nämlich:</p>
    <ul>
      <li>Die Konto-ID. Dies kann entweder eine separate Eigenschaft oder ein Teil der API-Endpunkt-URL sein.</li>
      <li>Die URL zum Proxy, die davon abhängt, wo Sie Ihren Proxy speichern.</li>
      <li>Der HTTP-Methodentyp zum Beispiel <code translate="No">GET</code> , <code translate="No">POST</code> oder <code translate="No">PATCH</code>.</li>
      <li>Die API-Endpunkt-URL, die vom Proxy verwendet wird, um die eigentliche Anfrage von der API zu stellen. Zum Beispiel:
        <pre class="line-numbers">
	<code class="language-html" translate="No">https://players.api.brightcove.com/v2/accounts/57838016001/players
	https://edge.api.brightcove.com/playback/v1/accounts/1752604059001/videos/5842800655001
	https://analytics.api.brightcove.com/v1/alltime/accounts/1752604059001/videos/4093643993001</code></pre>
      </li>
    </ul>
    <p>Je nach API-Anforderung können im Optionsobjekt andere Eigenschaften erforderlich sein. Hier ist ein Beispiel dafür, was Sie in der Konsole sehen würden, wenn Sie das Optionsobjekt protokollieren, um eine Anfrage für alle Spieler in einem bestimmten Konto zu stellen:</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="debugging options simple" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/debugging-options-simple.png" /></figure>
    <p>Hier ist ein etwas komplexeres protokolliertes Optionsobjekt, das beim Aktualisieren von Spielern verwendet wird:</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="debugging options" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/debugging-options.png" /></figure>
    <h3>Zurückgegebene Daten anzeigen</h3>
    <p>Was zurückgegeben wird, hängt davon ab, welche Daten Sie angefordert haben und ob ein Fehler zurückgegeben wird. Aber egal, was zurückgegeben wird, Sie werden höchstwahrscheinlich sehen wollen, welche Daten zurückgegeben werden. Eine einfache Möglichkeit, dies zu tun, besteht darin, das Raw in der Konsole zu loggen <code translate="No">response</code> Daten direkt nach dem Anruf bei der <code translate="No">makeRequest</code> Funktion:</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="debugging code log options" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/debugging-code-log-response.png" /></figure>
    <p>Was zurückgegeben wird, hat fast unendliche Möglichkeiten, aber es folgen einige Beispiele. Die erste zeigt den Beginn einer Antwort, wenn nach allen Spielern in einem Konto gefragt wird:</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="debugging response on players request" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/debugging-response-multiple-players.png" /></figure>
    <aside class="bcls-aside bcls-aside--tip">Dies ist ein gutes Beispiel dafür, wenn das Anzeigen der Antwort äußerst hilfreich sein kann, da es zeigt, dass die Spielerinformationen in einem Array namens . gespeichert sind <code translate="No">items</code>.</aside>
    <p>Hier ist die Antwort nach dem Aktualisieren von Spielern mit dem <code translate="No">PATCH</code> HTTP-Methode:</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="debugging response on player patch" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/debugging-response-on-player-patch.png" /></figure>
    <p>Hier ist eine schöner formatierte Ansicht der Daten in der ersten Antwort:</p>
    <pre class="line-numbers">
	<code class="language-json" translate="No">{
		"id": "1OHQdsTAr",
		"preview_url": "http://preview-players.brightcove.net/v2/accounts/.../master/index.html",
		"preview_embed_in_page": "http://preview-players.brightcove.net/v2/accounts/.../master/in_page.embed",
		"preview_embed_code": "&lt;iframe src='//preview-players.brightcove.net/v2/accounts/.../master/index.html' ...&gt;&lt;/iframe&gt;"
	}</code></pre>
    <p>Und schließlich ist hier eine sehr wertvolle Antwort, wenn ein Fehler aufgetreten ist. In diesem Fall wurde ein Konto ohne die richtigen Anmeldeinformationen verwendet:</p>
    <figure class="bcls-figure"><img class="bcls-image" alt="debugging response on error" src="//learning-services-media.brightcove.com/doc-assets/player-development/architecture/proxy-API-call/debugging-response-on-error.png" /></figure>
  </section>
  <h3>Weitere Tipps zur Fehlerbehebung</h3>
  <p>Wenn Sie Probleme haben, finden Sie hier einige andere Dinge, auf die Sie achten sollten.</p>
  <dl>
    <dt>Bekomme keine Antwort</dt>
    <dd>Es gibt ein paar Dinge zu überprüfen, wenn Sie eine leere Antwort erhalten:
      <ul>
        <li>Überprüfen Sie die API-Referenz, um sicherzustellen, dass die Anfrage eine Antwort zurückgibt. Einige geben nur eine 201- oder 204-Antwort ohne Inhalt zurück (insbesondere, aber nicht nur DELETE-Anforderungen). Sie müssen Ihren Code anpassen, um diesen Fall zu behandeln.</li>
        <li>Überprüfen Sie den Abschnitt Netzwerk der Entwicklertools in Ihrem Browser, um sicherzustellen, dass ein erfolgreicher Aufruf des Proxys angezeigt wird (dieser Server könnte vorübergehend nicht verfügbar sein):
          <figure class="bcls-figure"><img class="bcls-image" alt="Developer Tools Network Section" src="https://learning-services-media.brightcove.com/doc-assets/node/18132-learning-guide-rest-apis/developer-tools-network.png" />
            <figcaption class="bcls-caption--image">Abschnitt "Netzwerk der Entwicklertools"</figcaption>
          </figure>
        </li>
      </ul>
    </dd>
    <dt>Ich sehe eine Antwort, aber wenn ich es versuche <code translate="No">JSON.parse()</code> es, ich bekomme eine Ausnahme.</dt>
    <dd>Einige Möglichkeiten hier:
      <ul>
        <li>Siehe den vorherigen Punkt – der Versuch, einen leeren Sting zu parsen, löst eine JSON-Ausnahme aus</li>
        <li>
          <p>Sehen Sie sich die Antwort an und stellen Sie sicher, dass es sich um eine JSON-Zeichenfolge handelt (beginnend mit a <code translate="No">{</code> oder ein <code translate="No">[</code>). Es gibt einige Fälle, in denen eine Anfrage möglicherweise kein JSON zurückgibt - und <span translate="No">Analytics-API</span> rufen Sie zum Beispiel an, wenn Sie die <code translate="No">format</code> Parameter zu <code translate="No">csv</code> oder <code translate="No">xlxs</code>. Auch hier müssen Sie Ihren Code anpassen, um Nicht-JSON-Antworten zu verarbeiten.</p>
        </li>
        <li>In den meisten Fällen liegen von den APIs zurückgegebene Fehler ebenfalls im JSON-Format vor, es gibt jedoch einige Ausnahmen, bei denen der Fehler als Nur-Text oder HTML zurückgegeben wird.</li>
      </ul>
    </dd>
  </dl>
  <section class="bcls-section">
    <h2 id="Proxy_code">Proxy-Code</h2>
    <p>Wie bereits erwähnt, kann die Vollmacht in der Sprache Ihrer Wahl verfasst werden. Die Dokumentationsbeispiele für die Brightcove-API verwenden einen in PHP geschriebenen Proxy. Da die Implementierung des Proxys so sprachabhängig ist, wird der folgende PHP-Code in diesem Dokument nicht im Detail analysiert.</p>
    <p>Die von einem Proxy bereitgestellte Grundfunktionalität muss Folgendes umfassen:</p>
    <ol>
      <li>Akzeptieren Sie die Kundenanfrage.</li>
      <li>Holen Sie sich ein <strong>Authentifizierungstoken</strong> von der OAuth-API.</li>
      <li>Senden Sie das Authentifizierungstoken und die Datenanforderung (Endpunkt) an die vorgesehene API.</li>
      <li>Empfangen Sie Daten von der API zurück.</li>
      <li>Senden Sie die Daten an den Client zurück.</li>
    </ol>
    <pre class="line-numbers">
	<code class="language-javascript" translate="No">&lt;?php
	/**
	 * proxy for Brightcove RESTful APIs
	 * gets an access token, makes the request, and returns the response
	 * Accessing:
	 *     (note you should **always** access the proxy via HTTPS)
	 *     Method: POST
	 *     request body (accessed via php://input) is a JSON object with the following properties
	 *
	 * {string} url - the URL for the API request
	 * {string} [requestType=GET] - HTTP method for the request
	 * {string} [requestBody] - JSON data to be sent with write requests
	 * {string} [client_id] - OAuth2 client id with sufficient permissions for the request
	 * {string} [client_secret] - OAuth2 client secret with sufficient permissions for the request
	 *
	 * Example:
	 * {
	 *    "url": "https://cms.api.brightcove.com/v1/accounts/57838016001/video",
	 *    "requestType": "PATCH",
	 *    "client_id": "0072bebf-0616-442c-84de-7215bb176061",
	 *    "client_secret": "7M0vMete8vP_Dmb9oIRdUN1S5lrqTvgtVvdfsasd",
	 *    "requestBody": "{\"description\":\"Updated video description\"}"
	 * }
	 *
	 * if client_id and client_secret are not included in the request, default values will be used
	 *
	 * @returns {string} $response - JSON response received from the API
	 */
	
	// security checks
	// if you want to do some basic security checks, such as checking the origin of the
	// the request against some white list, this would be a good place to do it
	// CORS enablement and other headers
	header("Access-Control-Allow-Origin: *");
	header("Content-type: application/json");
	header("X-Content-Type-Options: nosniff");
	header("X-XSS-Protection");
	
	// default account values
	// if you work on one Brightcove account, put in the values below
	// if you do not provide defaults, the client id, and client secret must
	// be sent in the request body for each request
	$default_client_id     = 'YOUR_CLIENT_ID';
	$default_client_secret = 'YOUR_CLIENT_SECRET';
	
	// get request body
	$requestData = json_decode(file_get_contents('php://input'));
	
	// set up access token request
	// check to see if client id and secret were passed with the request
	// and if so, use them instead of defaults
	if (isset($requestData-&gt;client_id)) {
			$client_id = $requestData-&gt;client_id;
	}
	
	if (isset($requestData-&gt;client_secret)) {
			$client_secret = $requestData-&gt;client_secret;
	}
	
	$auth_string = "{$client_id}:{$client_secret}";
	
	// make the request to get an access token
	$request = "https://oauth.brightcove.com/v4/access_token?grant_type=client_credentials";
	$curl          = curl_init($request);
	curl_setopt($curl, CURLOPT_USERPWD, $auth_string);
	curl_setopt($curl, CURLOPT_POST, TRUE);
	curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);
	curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);
	curl_setopt($curl, CURLOPT_HTTPHEADER, array(
		'Content-type: application/x-www-form-urlencoded',
	));
	
	$response = curl_exec($curl);
	$curl_info = curl_getinfo($curl);
	$php_log = array(
		"php_error_info" =&gt; $curl_info
	);
	$curl_error = curl_error($curl);
	
	curl_close($curl);
	
	// Check for errors
	// it's useful to log as much info as possible for debugging
	if ($response === FALSE) {
		log_error($php_log, $curl_error);
	}
	
	// Decode the response and get access token
	$responseData = json_decode($response, TRUE);
	$access_token = $responseData["access_token"];
	// get request type or default to GET
	$method = "GET";
	if ($requestData-&gt;requestType) {
			$method = $requestData-&gt;requestType;
	}
	
	// get the URL and authorization info from the form data
	$request = $requestData-&gt;url;
	// check for a request body sent with the request
	if (isset($requestData-&gt;requestBody)) {
		$data = $requestData-&gt;requestBody;
	}
		$curl = curl_init($request);
		curl_setopt($curl, CURLOPT_RETURNTRANSFER, TRUE);
		curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);
		curl_setopt($curl, CURLOPT_HTTPHEADER, array(
			'Content-type: application/json',
			"Authorization: Bearer {$access_token}"
		));
		switch ($method)
			{
				case "POST":
					curl_setopt($curl, CURLOPT_POST, TRUE);
					if ($requestData-&gt;requestBody) {
						curl_setopt($curl, CURLOPT_POSTFIELDS, $data);
					}
					break;
				case "PUT":
					// don't use CURLOPT_PUT; it is not reliable
					curl_setopt($curl, CURLOPT_CUSTOMREQUEST, $method);
					if ($requestData-&gt;requestBody) {
						curl_setopt($curl, CURLOPT_POSTFIELDS, $data);
					}
					break;
				case "PATCH":
					curl_setopt($curl, CURLOPT_CUSTOMREQUEST, $method);
					if ($requestData-&gt;requestBody) {
						curl_setopt($curl, CURLOPT_POSTFIELDS, $data);
					}
					break;
				case "DELETE":
					curl_setopt($curl, CURLOPT_CUSTOMREQUEST, $method);
					if ($requestData-&gt;requestBody) {
						curl_setopt($curl, CURLOPT_POSTFIELDS, $data);
					}
					break;
				default:
					// GET request, nothing to do;
			}
		$response = curl_exec($curl);
		$curl_info = curl_getinfo($curl);
		$php_log = array(
			"php_error_info" =&gt; $curl_info
		);
		$curl_error = curl_error($curl);
		curl_close($curl);
	
	// Check for errors and log them if any
	// note that logging will fail unless
	// the file log.txt exists in the same
	// directory as the proxy and is writable
	
	if ($response === FALSE) {
		log_error($php_log, $curl_error);
	}
	
	function log_error($php_log, $curl_error) {
		$logEntry = "\nError:\n". "\n".date("Y-m-d H:i:s"). " UTC \n" .$curl_error. "\n".json_encode($php_log, JSON_PRETTY_PRINT);
		$logFileLocation = "log.txt";
		$fileHandle      = fopen($logFileLocation, 'a') or die("-1");
		fwrite($fileHandle, $logEntry);
		fclose($fileHandle);
		echo "Error: there was a problem with your API call"+
		die(json_encode($php_log, JSON_PRETTY_PRINT));
	}
	
	// return the response to the AJAX caller
	echo $response;
	?&gt;</code></pre>
    <p>Obwohl der gesamte Code für den Proxy-Server oben gezeigt wird, befindet er sich auch im GitHub-Repository: <a href="https://github.com/BrightcoveLearning/sample-proxy-apps">Beispiel-Proxy-Apps</a> in dem <strong>php</strong> Mappe.</p>
  </section>
  <section class="bcls-section">
    <h2 id="Example_2">Beispiel 2</h2>
    <p>Dieses zweite Beispiel ist komplexer als das zuvor beschriebene. In diesem Beispiel werden die 10 beliebtesten Videos eines Kontos in einer Playlist angezeigt. Die wichtigsten Schritte des Codes sind:</p>
    <ol>
      <li>Anfrage vom <span translate="No">Analytics-API</span> die 10 Videos mit den meisten Aufrufen in einem Konto. Dieser Schritt beinhaltet einen asynchronen Aufruf mit einer Callback-Funktion.</li>
      <li>Aus dem zurückgekehrten <span translate="No">Analytics-API</span> Daten, extrahieren Sie nur die Video-IDs und platzieren Sie sie in einem Array. Eine Hilfsfunktion wird geschrieben, um die IDs aus den zurückgegebenen Daten zu extrahieren.</li>
      <li>Fordern Sie die vollständigen Videoobjekte für jedes der Videos in der Liste der IDs im Array an. Dieser Schritt beinhaltet das Schleifen über das Array und das Anfordern der Videoobjekte mit <code translate="No">player.catalog.getVideo()</code>. Dies beinhaltet natürlich mehrere asynchrone Aufrufe mit dem <code translate="No">catalog</code>. Es wird eine Hilfsfunktion geschrieben, um die Videoobjekte basierend auf IDs abzurufen und die Objekte in einem Array zu platzieren.</li>
      <li>Platzieren Sie das Array von Videoobjekten in der Playlist für einen Playlist-fähigen Player.</li>
    </ol>
    <p>Da Sie jetzt mit vielen Konzepten und spezifischem Code zum Aufrufen der APIs vertraut sind, wird nur der Code verwendet, der die APIs aufruft <code translate="No">makeRequest()</code> Funktion ist ausführlich beschrieben.</p>
    <ul>
      <li>Zeile 2: Ruf die <code translate="No">makeRequest()</code> -Funktion, die als Argumente die für einen erfolgreichen REST-API-Aufruf erforderlichen Optionen zusammen mit einer anonym definierten Rückruffunktion (gelb hervorgehoben) übergibt. Das sollte von oben bekannt klingen. Ganz wichtig, die <code translate="No">makeRequest()</code> Die aufgerufene Funktion IST GENAU DIE GLEICHE FUNKTION, DIE IM VORHERIGEN BEISPIEL VERWENDET WURDE. Sie können das gleiche in Ihrem Code tun. Die <code translate="No">makeRequest()</code> Die Funktion wurde so geschrieben, dass sie bei allen Aufrufen einer Brightcove-REST-API wiederverwendet werden kann. <aside class="bcls-aside bcls-aside--tip">Die <code translate="No">mostWatchedVideos</code> Parameter wird der abgerufene Wert zugewiesen, wenn die Callback-Funktion in der <code translate="No">makeRequest()</code> Funktion.</aside>
      </li>
      <li>Zeile 3: Erstellen Sie eine Variable, um die JSON-geparsten zurückgegebenen Daten aufzunehmen.</li>
      <li>Zeile 5: Analysieren Sie die zurückgegebenen Daten, um sie von einer Zeichenfolge in ein Objekt zu konvertieren.</li>
      <li>Zeile 7: Verwenden Sie die Hilfsfunktion, um Video-IDs aus zurückgegebenen Daten zu extrahieren. Leider ist die <span translate="No">Analytics-API</span> gibt nicht die vollständigen Videoobjekte zurück, daher werden IDs benötigt, um auf die vollständigen Objekte zuzugreifen.</li>
      <li>Zeilen 9-12: Ruf die <code translate="No">getVideoData</code> Hilfsfunktion, die eine Callback-Funktion verwendet, um die <code translate="No">videoObjects</code> Array basierend auf den übergebenen IDs.</li>
      <li>Zeile 11: Füllen Sie die Wiedergabeliste mit dem Array von Videoobjekten.</li>
    </ul>
    <pre class="line-numbers">
	<code class="language-javascript" translate="No">// +++ Make the <span translate="No">CMS API</span> request to get matching video IDs +++
	makeRequest(options, <span class="bcls-highlight">function(mostWatchedVideos) {
		var JSONmostWatchedVideos;
		// Convert response string into JSON
		JSONmostWatchedVideos = JSON.parse(mostWatchedVideos);
		// Extract the needed video IDs into an array
		videoData = extractVideoData(JSONmostWatchedVideos);
		// Get video objects based on array of video IDs
		getVideoData(videoData, function(videoObjects) {
			// Add the most watched videos list to the player as a playlist
			myPlayer.playlist(videoObjects);
		});</span>
	});</code></pre>
    <h3>Codeauflistung komplett</h3>
    <p>Das komplette, funktionierende Beispiel befindet sich in diesem CodePen: <a href="https://codepen.io/team/rcrooks1969/pen/zRzZNG/">Meistgesehene Videos in einer Playlist</a>.</p>
  </section>
</article>